### JAVA

📌 JAVA
    🌱 JAVA는 썬에서 개발한 객체지향 언어이다. 가정용 단말기에 적용하려는 목적으로 1992년에 만든 '오크(OAK)'언어에서 비롯되었다.
    🌱 오크는 상품화되지 못했지만, 인터넷이 발전하면서 인터넷 진화적인 개발 언어로 방향을 전환하여 1995년 '자바(JAVA)'라는 이름으로 새롭게 소개되었다.
    🌱 현재 자바는 IT 기술 전반에서 가장 널리 사용되는 프로그래밍 언어가 되었다.

📌 JAVA 가상머신
    🌱 JAVA는 '바이트코드(Bytecode)'를 생성한다. 바이트코드는 하드웨어에 종속적이지 않은 중간 파일로, 가상머신을 거쳐 해석.실행하는 구조이다.
    🌱 가상머신으로 자바는 스마트폰, 컴퓨터, Mac, 리눅스 등 서로 다른 기기나 운영체제에서 동일한 프로그램을 개발하고 실행할 수 있다.

📌 JAVA Flatform
    🌱 JAVA Flatform은 자바 프로그램이 실행되는 특정 환경을 말한다.
    🌱 여러 제약(화면, 입출력 장치, 성능 등) 때문에 모든 하드웨어나 적용 분야에서 동일한 자바를 사용하는 것은 불가능하다.
    각 영역에 특화된 자바 플랫폼이 있다.
    🌱 대표적인 자바 플랫폼 기술로 Java SE(Standard Edition), Java ME(Micro Edition), Java EE(Enterprise Edition), Java Card, Java TV 등이 있다.
        💡JDK(Java Development Kit): 자바 프로그램 개발에 필요한 구성 요소
        💡JRE(Java Runtime Environment): 자바 프로그램 실행에 필요한 구성 요소
        💡API(Application Programming Interface): 자바 응용 프로그램 개발에 사용하는 라이브러리

📌 JAVA의 장점
    🌱 간결하면서도 강력한 객체지향 언어이다.
    🌱 개방형 구조로 여러 기술과 융합이 가능하다.
    🌱 플랫폼에 독립적이므로, 여러 운영체제나 하드웨어에서도 동일하게 실행한다.
    🌱 많은 오픈소스 프레임워크로 생산성을 증가하고 유지보수 비용을 절감할 수 있다.

📌 JAVA의 단점
    🌱 처리 속도가 중요한 애플리케이션에는 적합하지 않다.
    🌱 GUI 요소가 많은 MS 윈도우 응용 프로그램 개발에는 적합하지 않다.
    🌱 하드웨어에 연결하여 제어할 수 없기 때문에(가상머신 이용) 직접 하드웨어를 정밀하게 조정해야 하는 프로그램 개발에는 적합하지 않다.

### JAVA의 기초 문법

📌 변수와 자료형
    🌱 변수는 프로그램에서 데이터를 저장하는 공간을 말하고, 자료형은 변수에 저장할 데이터의 유형을 말한다.
    🌱 변수 이름 규칙
        💡변수 이름 길이에는 제한이 없다.
        💡반드시 문자나 언더바(_), 달러 기호($)로 시작해야 한다.
        💡자바의 연산자(+, -, *, /)는 변수 이름에 넣을 수 없다.
        💡대소문자를 구분한다(int result와 int Result는 다른 변수).
        💡첫 글자에 숫자가 올 수 없고, 이름 사이에 빈칸을 넣어서도 안된다. 빈칸 대신 언더바(_)를 사용한다.
        💡자바의 키워드는 변수 이름으로 사용할 수 없다.
    🌱 자바에서 변수 선언은 명시적으로 데이터형을 지정하게 되어 있으며, 선언된 데이터 유형과 대입된 데이터값에 차이가 있을 때 오류나 오버플로, 언더플로가 발생하므로 주의한다.
    🌱 자바의 변수는 유형에 따라 인스턴스 변수, 클래스 변수, 지역 변수, 파라미터로 구분한다.
    🌱 자바에서 지원하는 기본 자료형(Primitive Data Types)은 크게 정수형, 실수형, 논리형으로 나눈다.
    🌱 캐스팅 : 소괄호 사이에 해석 타입을 명시하여 해석하게 하는 것
        💡다운 캐스팅 : 넓은 범위에서 좁은 범위로 해석
        💡업 캐스팅 : 좁은 범위에서 넓은 범위로 해석

📌 여러가지 메소드(Method)
    🌱 메소드 : 코드 묶음을 입력 값을 사용하여 수행할 수 있음 
        💡호출부 -> 정의부
    🌱 타입.pasre타입(문자); = 문자열을 정수로 변환하는 메소드
    🌱 타입.toString(숫자) = 정수를 문자열로 변환하는 메소드
    🌱 Scanner
        💡Import java.util.Scanner; : 프로그램 첫 행에 다음을 추가해 Scanner 클래스의 경로 이름을 컴파일러에 알림.
        💡Scanner in = new Scanner(System.in); : 키보드로 데이터를 입력 받기 위해 System.in 객체와 연결된 Scanner 객체를 생성.
        💡Int x = in.nextint(); : Scanner 클래스가 제공하는 다양한 메서드를 이용해 키보드로 데이터를 입력 받음.
    🌱 메소드 호출 방법 = 메소드명(입력값1, 입력값2 ...)제어문 : 프로그램의 흐름에 영향을 주고 때에 따라 제어가 가능하도록 하는 것.
        💡즉 실행문의 수행 순서를 변경

📌 prinf()의 형식 문자와 자료형
    형식 문자    자료형    형식 문자            자료형
       %c       문자형        %o           8진수
       %d       정수형        %s           문자열
       %e       지수형        %u           부호 없는 정수형
       %f       실수형        %x           16진수
       %d       정수형      %%, |%         % 문자 출력

📌 정수형
    자료형          크기        입출력 범위                                         설명
    byte          1바이트      -2^7 ~ 2^7-1    작은 범위의 값을 저장하기에 유용하다. 컴퓨터 데이터 통신 프로그램에서 많이 사용한다.
    char          2바이트       0 ~ 2^16-1     음수를 표현하지 않는 unsigned 자료형으로, 문자를 저장하거나 출력하는 용도로 사용한다.
    short         2바이트     -2^15 ~ 2^15-1   메모리에서 차지하는 크기가 작다는 것이 장점이지만, 잘 사용하지 않는다.
    int           4바이트     -2^31 ~ 2^31-1   정수 타입의 연산에 기본이 되는 자료형이다.
    long          8바이트     -2^63 ~ 2^63-1   정수 표현 범위가 큰 데이터를 저장히기에 유용한 자료형이다.

📌 실수형
    자료형      크기          입출력 범위                             설명
    float     4바이트   1.4E^-45 ~ 3.402823E^38     표현 범위가 작다. 값을 지정할 때 숫자 뒤에 f나 F를 붙여서 구분한다.
    double    8바이트   4.9E^324 ~ 3.402823E^308    실수형에서 사용하는 기본 데이터형이다.

📌 논리형
    boolean : 1바이트, true값 또는 false 값만 가진다.

📌 연산자
    🌱 연산자는 프로그래밍 언어에서 사용할 수 있는 다양한 계산식이다.
    🌱 컴퓨터 연산자에는 사칙 연산, 관계 연산, 논리 연산 등이 있다.
        💡숫자 연산에서 정수와 정수 연산의 결과 -> 정수	
        💡숫자 연산에서 정수와 실수 연산의 결과 -> 실수

📌 연산자 우선 순위
    우선순위             연산자
       1                . [] ()
       2                ! ~ +/- ++/-- (cast)
       3                + - * / %
       4                << >> >>>
       5                < > <= >= == !=
       6                & ^ |   
       7                && ||
       8                [조건식]?[true]:[false]
       9                = += -= *= /= %= <<= >>= ^= &= !=
      10                ++/--(후위형 증감 연산자)

📌 산술 연산자
            분류        연산자              설명
        이항 연산자      +             두 수의 합을 구한다.
                        -             두 수의 차를 구한다.  
                        *             두 수의 곱을 구한다.
                        /             두 수를 나눈 몫을 구한다.
                        %             두 수를 나눈 나머지를 구한다.
                        +=            좌변과 우변을 더한 결과를 좌변에 대입한다.
                        -=            좌변에서 우변을 뺀 결과를 좌변에 대입한다.
                        %=            좌변에서 우변을 나눈 나머지를 좌변에 대입한다.
        단항 연산자     ++             변수값을 1 증가시킨다.
                        --            변수값을 1 감소시킨다.

📌 관계 연산자
    연산자                      설명
    >               왼쪽 항이 크면 참, 아니면 거짓
    <               오른쪽 항이 크면 참, 아니면 거짓
    >=              왼쪽 항이 크거나 같으면 참, 아니면 거짓
    <=              오른쪽 항이 크거나 같으면 참, 아니면 거짓
    ==              왼쪽과 오른쪽 항이 같으면 참, 아니면 거짓
    !=              왼쪽과 오른쪽 항이 다르면 참, 아니면 거짓

📌 논리 연산자
    연산자                                  설명
    &&                          두 항의 논리값이 참이면 참, 아니면 거짓
    ||                          두 항의 논리값 중 하나 이상의 항이 참이면 참, 아니면 거짓
    !                           단항 연산을 하며, 연산되는 항이 참이면 거짓, 거짓이면 참
    [조건식]?[true]:[false]     조건식의 결과가 참일 때 [true]항을 수행하고, 아니면 [false] 항을 수행한다.

📌 비트 연산자
        분류        연산자                      설명
     비트 논리         &         두 항이 비트가 모두 1이면 1, 아니면 0으로 연산
                      |         두 항의 비트가 모두 0이면 0, 아니면 1로 연산
                      ^         두 항의 비트가 서로 다르면 1, 같으면 0으로 연산
     비트 시프트       >>        왼쪽 피연산자를 오른쪽 값만큼 부호 비트로 채우면서 오른쪽으로 이동시킨다.
                      <<        왼쪽 피연산자를 오른쪽 값만큼 비트를 왼쪽으로 이동시킨다.
                      >>>       왼쪽 피연산자를 오른쪽 값만큼 부호 비트를 무시한 채 0으로 채우면서 오른쪽으로 이동시킨다.
     비트 대입        &=        두 항의 비트가 모두 1이면 1, 아니면 0으로 연산하여 왼쪽 피연산자에 대입한다.
                      |=        두 항의 비트가 모두 0이면 0, 아니면 1로 연산하여 왼쪽 피연산자에 대입한다.
                      ^=        두 항의 비트가 서로 다르면 1, 같으면 0으로 연산하여 왼쪽 피연산자에 대입한다.
                      >>=       왼쪽 피연산자를 오른쪽 값만큼 부호 비트로 채우면서 오른쪽으로 이동한 후 대입한다.
                      <<=       왼쪽 피연산자를 오른쪽 값만큼 비트를 왼쪽으로 이동한 후 대입한다.

📌 분기문
    🌱 분기문은 프로그램을 개발할 때 논리적 수행을 지원하는 명령어이다.
    🌱 자바에서 지원하는 분기문은 if문과 switch문이 있다.
    🌱 if문은 중첩 사용이 가능하며, if ~ else if ~ else 문 등 응용이 가능하다. switch문은 정수형 뿐만 아니라 문자열 비교로 case별 처리가 가능하다.

```java
if (조건값 1) {
    명령문;
}
else if(조건값 2) {
    명령문;
}
else if(조건값 3) {
    명령문;
}
else {
    명령문;
}
```
```java
if(조건값 1) {
    명령문;
    if(조건값 2) {
        명령문;
    }
}
else {
    명령문;
    if(조건값 3) {
        명령문;
    }
}
```
```java
switch (조건값) {
    case 조건 1:
        명령문;
        break;
    case 조건 2:
        명령문;
        break;
    case 조건 3:
        명령문;
        break;
    default:
        명령문;
        break;
}
```
📌 반복문
    🌱 반복문은 순환문이라고도 하며, 분기문과 함께 프로그램에서 기본적인 로직을 구성하는 기본 문법 중 하나이다.
    🌱 패턴이 일정하여 반복적으로 일을 수행할 때 순환문을 사용하면 쉽게 결과를 확인할 수 있다.
        자바 언어에서 지원하는 순환문으로는 for문과 while문이 있다.
    🌱 for문은 시작과 조건, 증감식 등으로 구성된다.
        while문은 조건을 충족하는 동안 계속 수행하는 반복문으로 경우에 따라 do ~ while문의 형태로도 사용이 가능하다.
```java
for (초기값; 조건값; 증감식) {
    명령문;
}
```
```java
while (조건값) {
    명령문;
}

-------------

do {
    명령문;
}
while (조건값)
```
    🌱 메소드 오버로딩 (Method Overloading)
        💡메소드 이름은 같지만 메소드 시그니처가 다른 메서드를 정의하는 것.