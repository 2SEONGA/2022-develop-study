- Object-oriented Programming
    - 클래스 선언과 객체 생성
        - 클래스 선언의 형식
            
            ```java
            class /* 클래스를 선언하기 위한 키워드 */ 클래스이름 {
            		// 필드 /* 객체의 속성 */
            		// 메서드 /* 객체의 동작 */
            }
            ```
            
            ![스크린샷 2022-08-19 오후 6.38.28.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/18513a30-5b9f-457d-bf56-9addc26212e6/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-08-19_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_6.38.28.png)
            
        - 클래스 선언과 (소스) 파일
            - 보통 팡리마다 1개 클래스를 선언하지만, 2개 이상의 클래스를 1개 파일로 선언 가능
            - 하나의 파일에 클래스가 둘 이상 있다면 하나만 public으로 선언할 수 있고, 해당 클래스 이름은 소스 파일 이름과 동일해야한다.
        - 객체 생성과 참조 변수
            
            ```java
            - 객체 변수 선언과 생성
            클래스이름 /* 변수의 타입 */ 변수 /* 클래스는 참조 타입이므로 참조 변수 또는 참조 타입 변수 */ ;
            변수 = new 클래스이름() /* 생성자 */ ;
            - 변수를 생략한 객체 생성
            new 클래스이름();
            - 한 문장으로 변수 선언과 객체 생성
            클래스이름 = 변수 new 클래스이름();
            ```
            
        - 기초 타입과 참조 타입
            
            ```java
            int ten = 10;
            Ball myBall = new Ball();
            ```
            
            ![스크린샷 2022-08-19 오후 6.53.02.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5e49ea95-37b1-440a-ac07-e150548f55a9/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-08-19_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_6.53.02.png)
            
    - 클래스의 구성 요소와 멤버 접근
        - 클래스의 구성 요소
            - 멤버 = 필드 + 메소드
            - 생성자 (new 연산자로 호출)
        - 필드와 지역 변수의 차이
            - cf) 지역 변수
                - 매개 변수, 메소드 내부에 선언된 변수 (for 문 등 블록 내부도)
                - 필드는 기본 값이 있지만, 지역 변수는 기본 값이 없어 반드시 초기화
                - 필드는 클래스 전체에서 사용할 수 있지만, 지역 변수는 선언된 블록 내부의 선언된 후에만 사용 가능
                - 지역 변수는 선언된 블록 내부에서만 사용 가능
        - 필드와 메소드 접근
            
            > 객체참조변수.멤버
            > 
            - 클래스 내부에서 자신의 멤버에 접근
                - 참조 변수 this 혹은 참조 변수 없이 멤버 이름 그대로 사용
                - ex) 외부 클래스 Circle의 객체 myCircle이 있다면,
                    
                    myCircle 객체의 radius와 findArea()는 다음과 같은 방식으로 접근
                    
                    ![스크린샷 2022-08-20 오후 4.22.06.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7ed7c619-e857-4457-a340-90c27177fe09/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-08-20_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_4.22.06.png)
                    
                - 즉, 클래스가 radius 필드와 findArea() 메소드를 포함한다면 내부에서는 아래처럼사용
                    
                    ```java
                    radius 혹은 this.radius // 필드 이름
                    findArea() 혹은 this.findArea // 메소드 이름
                    ```
                    
        - 접근 제한자 (접근 제어자)
            - 접근 제한자의 종류
                - public : 모든 클래스의 접근 허용
                - protected : 동일 패키지 또는 상속 관계가 있는 클래스의 접근 허용
                - default : 동일 패키지(폴더)에 존재하는 클래스의 접근 허용
                - private: 모든 클래스의 접근 거부
            - 접근 제한자의 허용 범위
            
            ![스크린샷 2022-08-21 오전 2.31.17.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9111d90f-b237-4ca3-99a5-8109a5688053/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-08-21_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_2.31.17.png)
            
        - 접근자와 설정자
            - 필요성
                - 클래스 내부에 캡슐화된 멤버를 외부에서 사용할 필요성
                    - 즉, 즉, private으로 지정된 필드는 클래스 내부에서만 사용할 수 있으므로 이를 위해 접근자와 설정자 사용
                - 값을 반환하는 ‘접근자’(Getter method)
                    - private 필드를 외부로 반환하는 public 메소드로
                        
                        get + 필드 이름의 형태로 작성, 
                        
                        반환 타입은 대상 필드와 동일
                        
                        public 선언은 클래스 밖의 모든 코드에서 호출 가능
                        
                - 값을 변경하는 ‘설정자’(Setter method)
                    - private 필드를 외부에서 변경하게 하는 public 메소드로
                        
                        set + 필드 이름의 형태로 작성,
                        
                        반환 타입은 void
                        
                        public 선언은 클래스 밖의 모든 코드에서 호출 가능
                        
                - 생성자
                    
                    객체를 생성하는 시점에서 필드를 다양하게 초기화
                    
                    - 선언 방식
                        
                        ```java
                        클래스이름 (...) {...}
                        ```
                        
                    - 사용
                        
                        ```java
                        클래스이름 변수 = new 클래스이름(...);
                        ```
                        
                        - 생성자 이름은 클래스 이름과 같다.
                        - 생성자의 반환 타입은 없다.
                        - 생성자는 new 연산자와 함께 사용하며, 객체를 생성할 때 호출한다.
                        - 생성자도 오버로딩 할 수 있다.
                    - 디폴트 생성자
                        - 모든 클래스는 최소한 하나의 생성자가 존재
                        - 생성자를 선언하지 않으면 컴파일러가 자동으로 디폴트 생성자를 추가
                    - 생성자 오버로딩(Overloading)
                        
                        메소드와 같이 오버로딩 가능
                        
                    - this와 this()
                        
                        ```java
                        class Square {
                        	private double side /* 멤버 필드 */ ;
                        
                        	public void setRadius(double s /* 멤버 필드처럼 정사각형 변을 의미하지만, 변수 이름은 상이 */ ) {
                        		side = s;
                        	}
                        }
                        ```
                        
                        ```java
                        class Square {
                        	private double side;
                        
                        	public void setRadius(double side) {
                        		this.side /* 멤버 필드 */ = side /* 매개변수 */;
                        	}
                        }
                        ```
                        
                    - 연속 호출
                        - 메서드를 호출할 때마다 새로운 실행문을 사용해야 하므로 번거롭고 가독성도 낮다.
                - 인스턴스 멤버와 정적 멤버
                    
                    Java는 static 키워드로 클래스의 필드를 공유할 수 있도록 지원
                    
                    ![스크린샷 2022-08-22 오전 12.02.03.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1360eef9-4353-47a5-a409-06ca390467fc/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-08-22_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_12.02.03.png)
                    
                    - 인스턴스 변수
                        
                        static 키워드로 지정되지 않아 공유되지 않은 필드로,
                        인스턴스마다 자신의 필드를 생성
                        
                        - 인스턴스 변수는 객체별로 관리
                            
                            객체를 생성할 때 인스턴스 변수도 생성,객체가 소멸될 때는 자동으로 소멸
                            
                    - 정적 변수 또는 클래스 변수
                    static 키워드로 지정하여 모든 인스턴스가 공유하는 필드
                        - 정적 변수는 클래스 로더가 클래스를 메서드 영역에 적재할 때 생성
                - 정적 멤버의 활용
                    
                    ```java
                    클래스이름 /* 정적 멤버는 일반적으로 클래스 이름과 연결해서 사용 */ .정적변수이름
                    클래스이름.정적메소드이름()
                    ```
                    
                    - 상수는 변경되지 않는 변수이기 때문에 final 키워드로 지정
                        
                        final로만 지정하면 객체마다 자신의 기억 공간
                        
                    - 상수는 값이 변경되지 않으므로 객체마다 따로 기억 공간을 할당 불필요
                        
                        따라서 static final로 지정해서 선언
                        
                    
                    ```java
                    static /* 모든 객체가 공유 */ final /* 초깃값이 대입되면 수정 불가능 */a 데이터형 상수 = 초깃값;
                    ```
                    